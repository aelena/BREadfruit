; validator used is http://apps.mrochek.com/content/chris-newmans-abnf-validator

; Literals

entity = "Entity"
textbox = "textbox"
checkbox = "checkbox"
dropdownlist = "dropdownlist"
multiline = "multiline"
radiobutton = "radiobutton"
label = "label"
div = "div"
calendar = "calendar"
button = "button"
object = "object"
dynamic = "dynamic"

clear = "clear"
role = "role"
then = "then"
in = "in"


; for with statements separating the scopes of each entity in the file
with = "with"
defaults = "defaults"
rules = "rules"
triggers = "triggers"
constraints = "constraints"


value = "value"	
boolean = "true" / "false"							



; Default-Literals:

; the following are used in default clauses - see 'with defaults' section in sample business rule file
max-length = "max_length" / "max length"
min-length = "min_length" / "min length"
mandatory = "mandatory"
not-mandatory = "not mandatory"
enabled = "enabled"
disabled = "disabled"
visible = "visible"
not-visible = "not visible" / "hidden"
checked = "checked"
unchecked = "unchecked"



; ---------------------------------------------------------------------------

; Operators: 

; operator literals, for comparison of values, constants etc...
and = "and"
or = "or"
is = "is"
not = "not"
is-not = "is not"
empty = "empty"
starts-with = "starts with"
not-starts-with = "not starts with"
ends-with = "ends with"
not-ends-with = "not ends with"
contains = "contains"							
not-contains = "not contains"					
bigger-than = "bigger than" / ">"
not-bigger-than = "not bigger than" / "!>"
lower-than = "lower than" / "<"
not-lower-than = "not lower than" / "!<"
bigger-equal-than = "bigger or equal than" / "<="
not-bigger-equal-than = "not bigger or equal than" / "!<="
lower-equal-than = "lower or equal than" / ">="
not-lower-equal-than = "not lower or equal than" / "!>="


; ---------------------------------------------------------------------------

; Action-Tokens:

; action token
show-element = "show element" / "show"
hide-element = "hide element" / "hide"
clear = "clear"
; denotes a change in a DOM element - used in the action part of conditions (after the 'then' token)
element-state-change = enabled / disabled / visible / not-visible / mandatory / not-mandatory / clear / checked / unchecked

set-value = "set value"


; ---------------------------------------------------------------------------


; Madam-Specific:

valid-role = "ENQ" / "UPM" / "CPM" / "SUS" / "RCO" / "CLERK"
regional-country = "RegionalCountry"
vendor-country = "VendorCountry"
customer-country = "CustomerCountry"
company-code = "CC" / "Company Code" / "CompanyCode" / "CoCd"
purchase-org = "Purchase Org" / "P.Org" / "P. Org" / "PO"
sales-org = "Sales Org" / "S.Org" / "S. Org" / "SO"
dist-channel ="Dist Channel" / "DC" / "Distribution channel"
division = "division"
country = "ES" / "PT" / "FR" / "IT" / "GR" / "BE" / "LU"
any-country = 2ALPHA
vendor-account-group = "YVT1" / "YVT2" / "YVT3" / "YVT4" / "YVT5" / "YVT6" / "YVT7" / "YVT9"
customer-account-group = "YCT1" / "YCT2" / "YCT3" / "YCT4" / "YCT5" / "YCT6" / "YCT7" / "YCT9"
multiple-vendor-account-group = "{" vendor-account-group SP [1*("," [SP] vendor-account-group)] "}"
multiple-customer-account-group = "{" customer-account-group SP [1*("," [SP]customer-account-group)] "}"

; ---------------------------------------------------------------------------

; Quotables:

squote = "'"
quote = DQUOTE / squote									
statement = *VCHAR										; not sure this covers for example greek characters...
quoted-statement = 1quote statement 1quote				


; ---------------------------------------------------------------------------


; Scopes:

; defines a valid identifier for an element, like an entity's name - should be at least 3 characters long
valid-identifier = 3*(ALPHA / DIGIT / "_") 

entity-type = textbox / checkbox / dropdownlist / multiline / radiobutton / label / div / button / object
entity-line = entity SP valid-identifier SP is SP entity-type

with-line = with SP (defaults / rules / triggers / constraints)


; ---------------------------------------------------------------------------

; Default-Clauses:

; valid default clauses for entities
value-default = value SP quoted-statement
mandatory-default = mandatory SP boolean
enabled-default = enabled SP boolean
disabled-default = disabled SP boolean
visible-default = visible SP boolean
checked-default = checked SP boolean
unchecked-default = unchecked SP boolean
max-length-default = max-length SP 1*DIGIT
min-length-default = min-length SP 1*DIGIT

; ---------------------------------------------------------------------------


; Conditions:


; for a then with a single action
then-clause = then SP valid-identifier SP element-state-change

; for a then with several actions
multiple-then-clause = then-clause SP [*("," then-clause)]

; basic stems for conditions
role-condition = role SP is SP valid-role		
vendor-country-condition  = vendor-country SP is SP (country / any-country) 
customer-country-condition  = customer-country SP is SP (country / any-country) 
country-condition = (vendor-country-condition / customer-country-condition)


; 1* is to state that these operators should work as "starts with any of the following values" 
; or "ends with any of the following values" sort of linq functionality
starts-with-condition = 1(valid-identifier / entity-value) SP starts-with SP quoted-statement *("," quoted-statement)
not-starts-with-condition = 1(valid-identifier / entity-value) SP not-starts-with SP quoted-statement *("," quoted-statement)
ends-with-condition = 1(valid-identifier / entity-value) SP ends-with SP quoted-statement *("," quoted-statement)
not-ends-with-condition = 1(valid-identifier / entity-value) SP not-ends-with SP quoted-statement *("," quoted-statement)

; 1* is to state that contains should work as "contains any of the following values" sort of linq functionality
; contains-condition = 1(valid-identifier / entity-value) contains quoted-statement *("," quoted-statement)
;not-contains-condition = 1(valid-identifier / entity-value) not-contains quoted-statement *("," quoted-statement)
; this format should be better, for allowing single-item format or list format
; only, check if this nested format at the end of the line is actually valid
contains-condition = 1(valid-identifier / entity-value) contains (quoted-statement / ("{" quoted-statement *("," quoted-statement) "}"))
not-contains-condition = 1(valid-identifier / entity-value) contains (quoted-statement / ("{" quoted-statement *("," quoted-statement) "}"))



; TODO: Check if this is right and if we should add markers for numbers like d, x, m etc.
new-digit = [-]1*DIGIT["."][1*DIGIT][("d" / "m" / "x")]
bigger-than-condition = 1(valid-identifier / entity-value) SP bigger-than SP 1(new-digit /  date-time)
not-bigger-than-condition = 1(valid-identifier / entity-value) SP not-bigger-than SP 1(new-digit /  date-time)
lower-than-condition = 1(valid-identifier / entity-value) SP lower-than SP 1(new-digit /  date-time)
not-lower-than-condition = 1(valid-identifier / entity-value) SP not-lower-than SP 1(new-digit /  date-time)


bigger-equal-than-condition = 1(valid-identifier / entity-value) SP bigger-equal-than SP 1(new-digit /  date-time)
not-bigger-equal-than-condition = 1(valid-identifier / entity-value) SP not-bigger-equal-than SP 1(new-digit /  date-time)
lower-equal-than-condition = 1(valid-identifier / entity-value) SP lower-equal-than SP 1(new-digit /  date-time)
not-lower-equal-than-condition = 1(valid-identifier / entity-value) SP not-lower-equal-than SP 1(new-digit /  date-time)


; multiple conditions
condition-clause = role-condition / country-condition / starts-with-condition / not-starts-with-condition
condition-clause =/	ends-with-condition / not-ends-with-condition / contains-condition / not-contains-condition /
condition-clause =/	bigger-than-condition / not-bigger-than-condition / lower-than-condition / not-lower-than-condition / 
condition-clause =/	bigger-equal-than-condition / not-bigger-equal-than-condition / lower-equal-than-condition / not-lower-equal-than-condition


full-condition = 1condition-clause SP *((and / or) condition-clause) SP multiple-then-clause


; for defining accessors like GD_Adr_Name1.Text or MyClass.Name
; the second part could be optional if we want to define default properties
entity-value = valid-identifier ["." valid-identifier]




; ---------------------------------------------------------------------------

; Actions:

; actions
; for example set  GD_Ctr_IsNaturalPerson unchecked
set-action = "set" SP valid-identifier SP (mandatory / not-mandatory / enabled / disabled / visible / not-visible  / checked / unchecked)

; for example -> set value 'G' in GD_Ctr_VendorClassification
set-value-action = set-value SP quoted-statement SP in SP (valid-identifier / entity-value)



; ---------------------------------------------------------------------------

; Triggers:

change-value = "changes value"
become-mandatory = "becomes mandatory"
become-non-mandatory = "becomes non mandatory"
lose-focus = "loses focus"
get-focus = "gets focus"
become-visible = "becomes visible"
become-hidden = "becomes not visible"
row-inserted = "row inserted"
row-deleted = "row deleted"
row-updated = "row updated"

valid-trigger = (change-value / become-mandatory / become-non-mandatory / lose-focus / get-focus / become-visible / become-hidden / row-inserted / row-deleted / row-updated )
trigger-clause = valid-identifier SP valid-trigger


; ---------------------------------------------------------------------------

; Constraints:

; constraints, sort of masks for textboxes basically
only-constraint = "only" SP ( "ascii" / "numbers" / "capitals" )


; ---------------------------------------------------------------------------


; this section is for defining how to denote a table lookup
; proposed format can be something like this identifying Input and Output cols
; table-lookup ( I:{'Col_1', 'Col_2'}, O:{'Col_3', 'Col_6'} )
; or
; table-lookup ( I:'Col_1', I:'Col_2', O:'Col_3', O:'Col_6' )
; Lookups:

; this means we can either send an object / dom element name, a full field or prop name or any arbitrary value
; entity-value is entity-value = valid-identifier ["." valid-identifier]
; so we can send either EntityName or EntityName.FieldName
; quoted-statement cover sending up something like 'My Name Is John' or any other data (serialized json for example)
valid-func-input = entity-value / quoted-statement

; output is more tricky, for the moment we assume we want to pass only quoted-statements
; to allow business rule to specify output column/field name only
table-lookup = "table-lookup" SP ( "name" SP quoted-statement [SP] "," [SP] "I:" [SP] valid-func-input *([SP] "," [SP] "I:" [SP] valid-func-input) [SP] "," [SP] "O:" [SP] quoted-statement *( [SP] "," [SP] "O:" quoted-statement) )


; represents external call to web service or similar
; service-call ( I:'Col_1', I:'Col_2', O:'Col_3', O:'Col_6' )
; however, there are many factors, here like URL, auth etc...
; these concerns should not be part of rule itself
; in the case of service calls output params could be full objects of fields thereof
service-call = "service-call" ( "name" quoted-statement "," "I:" valid-func-input *("," "I:" valid-func-input) "," "O:" valid-func-input *("," "O:" valid-func-input) )


; represents a business rule to send email
; we assume email-send params can be also literals or object values,
; for example, objects containing the data or functions returning said email data
email-send = "send-email" SP "subject:" [SP] valid-func-input ("," / SP) "body:" [SP] valid-func-input ("," / SP) "from:" [SP] valid-func-input ("," / SP) "to:" [SP] valid-func-input [("," / SP) "cc:" [SP] valid-func-input] [("," / SP) "bcc:" [SP] valid-func-input] [("," / SP) "attachments:" [SP] valid-func-input]


; ---------------------------------------------------------------------------

; Dates:

; THIS DATE GRAMMAR WAS OBTAINED FROM http://www.imc.org/ietf-calendar/archive1/msg00512.html - ISO 8601

 date-century      = 2DIGIT  ; 00-99
 date-decade       =  DIGIT  ; 0-9
 date-subdecade    =  DIGIT  ; 0-9
 date-year         = date-decade date-subdecade
 date-fullyear     = date-century date-year
 date-month        = 2DIGIT  ; 01-12
 date-wday         =  DIGIT  ; 1-7
 date-mday         = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on month/year
 date-yday         = 3DIGIT  ; 001-365, 001-366 based on year
 date-week         = 2DIGIT  ; 01-52
 
 datepart-fullyear = [date-century] date-year ["-"]
 datepart-ptyear   = "-" [date-subdecade ["-"]]
 datepart-wkyear   = datepart-ptyear / datepart-fullyear
 
 dateopt-century   = "-" / date-century
 dateopt-fullyear  = "-" / datepart-fullyear
 dateopt-year      = "-" / (date-year ["-"])
 dateopt-month     = "-" / (date-month ["-"])
 dateopt-week      = "-" / (date-week ["-"])
 
 datespec-full     = datepart-fullyear date-month ["-"] date-mday
 datespec-year     = date-century / dateopt-century date-year
 datespec-month    = "-" dateopt-year date-month [["-"] date-mday]
 datespec-mday     = "--" dateopt-month date-mday
 datespec-week     = datepart-wkyear "W" (date-week / dateopt-week date-wday)
 datespec-wday     = "---" date-wday
 datespec-yday     = dateopt-fullyear date-yday
 
 date              = datespec-full / datespec-year / datespec-month / datespec-mday / datespec-week / datespec-wday / datespec-yday
 
 ; Times:
 
 time-hour         = 2DIGIT ; 00-24
 time-minute       = 2DIGIT ; 00-59
 time-second       = 2DIGIT ; 00-60
 time-fraction     = ("," / ".") 1*DIGIT
 time-numzone      = ("+" / "-") time-hour [[":"] time-minute]
 time-zone         = "Z" / time-numzone
 
 timeopt-hour      = "-" / (time-hour [":"])
 timeopt-minute    = "-" / (time-minute [":"])
 
 timespec-hour     = time-hour [[":"] time-minute [[":"] time-second]]
 timespec-minute   = timeopt-hour time-minute [[":"] time-second]
 timespec-second   = "-" timeopt-minute time-second
 timespec-base     = timespec-hour / timespec-minute / timespec-second
 
 time              = timespec-base [time-fraction] [time-zone]
 
 date-time         = date ["T"] time
 
 ; Durations (periods):
 
 dur-second        = 1*DIGIT "S"
 dur-minute        = 1*DIGIT "M" [dur-second]
 dur-hour          = 1*DIGIT "H" [dur-minute]
 dur-time          = "T" (dur-hour / dur-minute / dur-second)
 dur-day           = 1*DIGIT "D"
 dur-week          = 1*DIGIT "W"
 dur-month         = 1*DIGIT "M" [dur-day]
 dur-year          = 1*DIGIT "Y" [dur-month]
 dur-date          = (dur-day / dur-month / dur-year) [dur-time]
 
 duration          = "P" (dur-date / dur-time / dur-week)
 
 ; Periods:
 
 period-explicit   = date-time "/" date-time
 period-start      = date-time "/" duration
 period-end        = duration "/" date-time
 
 period            = period-explicit / period-start / period-end